<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<title>Automate Docker base image updates with Watchtower - Dev&Ops</title>
<meta name=description content="If you host some simple hobby services with plain old Docker, chances are high that you have been thinking about how to automate the deployment process. If the services are small enough and you host them on your own servers or VM&rsquo;s, going to the PaaS cloud or introducing Kubernetes with a sophisticated CI/CD pipeline is, in most cases, total overkill.
Why invest more time in setting up the complicated hosting and scheduling platform than it took to write that 500 lines single-container web service?">
<meta name=author content="Andreas Mosti">
<link rel="preload stylesheet" as=style href=https://andmos.github.io/blog.amosti.net/app.min.css>
<link rel=preload as=image href=https://andmos.github.io/blog.amosti.net/theme.png>
<link rel=preload as=image href=https://andmos.github.io/blog.amosti.net/twitter.svg>
<link rel=preload as=image href=https://andmos.github.io/blog.amosti.net/github.svg>
<link rel=icon href=https://andmos.github.io/blog.amosti.net/favicon.ico>
<link rel=apple-touch-icon href=https://andmos.github.io/blog.amosti.net/apple-touch-icon.png>
<meta name=generator content="Hugo 0.92.1">
<meta property="og:title" content="Automate Docker base image updates with Watchtower">
<meta property="og:description" content="If you host some simple hobby services with plain old Docker, chances are high that you have been thinking about how to automate the deployment process. If the services are small enough and you host them on your own servers or VM&rsquo;s, going to the PaaS cloud or introducing Kubernetes with a sophisticated CI/CD pipeline is, in most cases, total overkill.
Why invest more time in setting up the complicated hosting and scheduling platform than it took to write that 500 lines single-container web service?">
<meta property="og:type" content="article">
<meta property="og:url" content="https://andmos.github.io/blog.amosti.net/automate-docker-base-image-updates-with-watchtower/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2019-11-03T08:43:52+00:00">
<meta property="article:modified_time" content="2019-11-03T08:43:52+00:00">
<meta itemprop=name content="Automate Docker base image updates with Watchtower">
<meta itemprop=description content="If you host some simple hobby services with plain old Docker, chances are high that you have been thinking about how to automate the deployment process. If the services are small enough and you host them on your own servers or VM&rsquo;s, going to the PaaS cloud or introducing Kubernetes with a sophisticated CI/CD pipeline is, in most cases, total overkill.
Why invest more time in setting up the complicated hosting and scheduling platform than it took to write that 500 lines single-container web service?"><meta itemprop=datePublished content="2019-11-03T08:43:52+00:00">
<meta itemprop=dateModified content="2019-11-03T08:43:52+00:00">
<meta itemprop=wordCount content="390">
<meta itemprop=keywords content>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Automate Docker base image updates with Watchtower">
<meta name=twitter:description content="If you host some simple hobby services with plain old Docker, chances are high that you have been thinking about how to automate the deployment process. If the services are small enough and you host them on your own servers or VM&rsquo;s, going to the PaaS cloud or introducing Kubernetes with a sophisticated CI/CD pipeline is, in most cases, total overkill.
Why invest more time in setting up the complicated hosting and scheduling platform than it took to write that 500 lines single-container web service?">
</head>
<body class=not-ready data-menu=true>
<header class=header>
<p class=logo>
<a class=site-name href=https://andmos.github.io/blog.amosti.net>Dev&Ops</a><a class=btn-dark></a>
</p>
<script>let bodyClx=document.body.classList,btnDark=document.querySelector('.btn-dark'),sysDark=window.matchMedia('(prefers-color-scheme: dark)'),darkVal=localStorage.getItem('dark'),setDark=a=>{bodyClx[a?'add':'remove']('dark'),localStorage.setItem('dark',a?'yes':'no')};setDark(darkVal?darkVal==='yes':sysDark.matches),requestAnimationFrame(()=>bodyClx.remove('not-ready')),btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark'))),sysDark.addEventListener('change',a=>setDark(a.matches))</script>
<nav class=menu>
<a href=/blog.amosti.net/about/>About Andreas</a>
</nav>
<nav class=social>
<a class=twitter style=--url:url(./twitter.svg) href=https://twitter.com/amostii target=_blank></a>
<a class=github style=--url:url(./github.svg) href=https://github.com/andmos target=_blank></a>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-title>
<p>
<time>Nov 3, 2019</time>
<span>Andreas Mosti</span>
</p>
<h1>Automate Docker base image updates with Watchtower</h1>
</header>
<section class=post-content><p>If you host some simple hobby services with plain old Docker, chances are high that you have been thinking about how to automate the deployment process. If the services are small enough and you host them on your own servers or VM&rsquo;s, going to the PaaS cloud or introducing Kubernetes with a sophisticated CI/CD pipeline is, in most cases, total overkill.</p>
<p>Why invest more time in setting up the complicated hosting and scheduling platform than it took to write that 500 lines single-container web service?</p>
<p>Don&rsquo;t fear, <a href=https://containrrr.github.io/watchtower/>watchtower</a> is here.</p>
<p>Watchtower is a single process container that runs on your system and <em>polls</em> a container registry (private or public, like Dockerhub) at given intervals to check for new versions of the base image on the running container(s) you want to update. If it detects a new image, Watchtower stores the parameters used to start the running container, like startup argument and environment variables, pulls down the new image, stops the running container, and starts it up again, with the same parameters, but with the new image. Easy as that. This simplifies the deployment process, and the only automation needed is a CI pipeline that builds the service&rsquo;s container image and pushes it to the registry when code is committed. Here is an example from my simple <a href=https://github.com/andmos/ReadingList>ReadingList</a> API:</p>
<p>In <code>.travis.yml</code>:</p>
<script src=https://gist.github.com/andmos/4783be0dda67cd8e74d598ef92c6006b.js></script>
<p>On push to master, if the build and test steps are successful, the image is tagged as <code>latest</code> and pushed to DockerHub. Nothing more to it.</p>
<p>Now on my private <a href=https://welcome.linode.com/>Linode</a> server the ReadingList API has been started <em>once</em> with the correct env-variables, so it&rsquo;s running as intended. Then Watchtower comes in:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker run -d --name watchtower  -v /var/run/docker.sock:/var/run/docker.sock containrrr/watchtower readinglist
</code></pre></div><p>Watchtower is now running and has access to <code>docker.sock</code> to be able to start and stop container.</p>
<p>When a change to ReadingList is merged and new image pushed, watchtower kicks in and replaces the running container with a new, updated version:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker logs watchtower
time<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2019-10-30T13:06:39Z&#34;</span> level<span style=color:#f92672>=</span>info msg<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Found new andmos/readinglist:latest image (sha256:803aa566d2dd53f3ec774406f6bd8e20cb4e926006cdc1012dc663e206fbc9dc)&#34;</span>
time<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2019-10-30T13:06:40Z&#34;</span> level<span style=color:#f92672>=</span>info msg<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Stopping /readinglist (45ceaaa2de930b22424438d1f2d078796feead127b0ab578c0ff8ac14dc8630e) with SIGTERM&#34;</span>
time<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2019-10-30T13:06:41Z&#34;</span> level<span style=color:#f92672>=</span>info msg<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Creating /readinglist&#34;</span>
time<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2019-10-30T13:13:38Z&#34;</span> level<span style=color:#f92672>=</span>info msg<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Waiting for running update to be finished...&#34;</span>
</code></pre></div><p>And thats it. Be mindful, this approach has limitations. When managing larger multi-container systems in production something like Kubernetes and a more thorough setup is recommended, but for the casual, single container hobby project Watchtower works just fine.</p>
</section>
<nav class=post-nav>
<a class=prev href=https://andmos.github.io/blog.amosti.net/local-reverse-proxy-with-nginx-mkcert-and-docker-compose/><span>←</span><span>Local reverse-proxy with Nginx, mkcert and Docker-Compose</span></a>
<a class=next href=https://andmos.github.io/blog.amosti.net/github-actions-and-publishing-artifacts-to-azure-blob-storage/><span>Github Actions and publishing artifacts to Azure Blob Storage</span><span>→</span></a>
</nav>
</article>
</main>
<footer class=footer>
<p>&copy; 2022 <a href=https://andmos.github.io/blog.amosti.net>Dev&Ops</a></p>
<p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p>
<p>
<a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a>
</p>
</footer>
</body>
</html>